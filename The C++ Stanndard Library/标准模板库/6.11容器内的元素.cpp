容器内的元素
    
    容器内的元素必须符合某些条件，因为容器乃是以一种特别方式来操作它们。本节将讨论这些条件。此外，容器会在内部对其元素进行复制，我也会讨论这种行为的后果。 

容器元素的必要条件 
    STL的容器、迭代器、算法都是template,因此它们可以操作任何类型——不论STL预定义的或用户自定义的，都可以。然而，由于某些加诸元素身上的操作，导致出现某些条件。STL容器元素必须满足以下三个基本要求： 
    1.元素必须可复制或可搬移（copyable or movable）也就是说，元素类型必须隐式或显式提供一个copy或move构造函数。 
    被制造出来的拷贝（generated copy）应该与其原件等效。这意味着对它们的任何相等性测试（test for equality）的结果都应该是相等的（equal）, 而且原件和拷贝的行为相同。 
    2.元素必须可被assignment操作符加以搬移或赋值。容器和算法以新元素覆写旧元素时用的是assignment操作符。
    3.元素必须可被一个析构函数销毁。当元素被移除（remove），容器会销毁该元素的内部拷贝。因此，析构函数一定不能是private。此外，一如C++惯常的做法，析构函数一定不可抛出异常，否则世事难料。

    这三个条件对任何class而言其实都是隐含成立的。如果某个class既没有为上述动作定义特殊版本，也没有定义任何特殊成员破坏这些动作的健全性，那么它自然而然也就满足了上述条件。 
    下面的条件也应当获得满足： 
    •对序列式容器而言，元素的default构造函数必须可用。我们可以在没有给予任何初值的情况下创建一个非空容器，或增加容器的元素个数。这些元素都将以default构造函数完成，不需任何实参。 
    •对于某些操作，必须定义操作符==以执行相等测试。如果你想査找元素，这一点特别重要。 
    •在关联式容器中，元素必须定义出适用于排序准别的操作。默认情况下是操作符 <，它将被函数对象less<>调用。 
    •无序容器应该为元素提供一个hash函数，和一个等同时测试准则（equivalence criterion） 。 详见7.9.2节第363页。

Value 语义 vs.Reference 语义 
    通常，所有容器都会建立元素拷贝（copy） ，返回的也是元素拷贝。这意味着容器内的元素与你放迸去的东西相等（equal）但非同一（identical） 。如果你修改容器的元素，实际上改变的是拷贝而不是原件。
    Value被复制意味着STL容器所提供的是value语义。它们容纳的是你安插的对象值，而不是对象本身。然而现实中你也许需要用到reference语义，让容器容纳元素的 reference。 
    STL只支持value语义，不支持reference语义。这当然是利弊参半。好处是： 
    •复制元素很简单。 
    •使用reference时容易导致错误。你必须确保reference所指对象仍然健在，并须小心对付偶尔出现的环式指向（circular  reference）状态。 
    缺点是： 
    •复制元素可能会导致不良的效率I有时甚至无法复制。 
    •无法在数个不同的容器中管理同一份对象。 
    现实中你同时需要两种做法。你不但需要一份独立（于原先对象）的拷贝（此乃value语义），也需要一份代表原数据、但能相应改变原值的拷贝（此乃reference语义）。不幸的是， C++标准库不支持reference语义。不过我们可以利用value语义实现reference语义。 
    一个显而易见的方法是以pointer作为元素。然而寻常的pointer有些常见问题，例如 它们指向的对象也许不复存在，pointer之间的“比较”行为也未必如你预期，因为实际比较的是pointer而非其所指对象。所以使用寻常pointer作为容器元素，必须非常谨慎。 
    好一点的办法是使用某种smart pointer，那是一种对象，有着类似pointer的接口，但内部做了一些额外检查和处理。事实上自TR1起，C++标准库提供了 class shared_ptr，这是个“可以共享相同对象”的smart pointer（见5.2.1节第76页）。
    此外，你可以使用class std::reference_wrapper<> (见 5.4.3 节第 132 页）让STL 容器持有reference。7.11节第388页为两种做法提供了一些例子。







