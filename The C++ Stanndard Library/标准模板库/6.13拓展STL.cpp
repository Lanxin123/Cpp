扩展 STL 
 
    STL被设计成一个框架（framework），可以向任何方向扩展。 
整合更多Type 
    
    你可以提供自己的容器、迭代器、算法或函数对象，前提是它们必须满足某些条件。事实上，C++标准库欠缺某些有用的扩充。之所以会这样是因为，在某一时间点，委员会必须停止为它加入新性质，把心力集中在完善既有成分上。否则工作永无休止。这就是hash table没有能够成为C++98的一部分的原因。 
    上述“有用的扩充”可以是迭代器（见9.6节第471页或14.3节第726页）、容器（见7.10节第385页）、算法（见7.6.2节第308页或9.5.1节第468页)。注意，所有这些扩充都遵循泛型编程（generic programming）原则： 
    •凡是行为像容器的东西，它就是个容器。 
    •凡是行为像迭代器的东西，它就是个迭代器。 
    因此，每当你有一个“像容器”的class，你就可以借由提供相应接口（begin()、end()和若干类型定义等）把它整合到STL框架中。如果你无法为这样的class添加成员，你还是可以提供一个外覆器（wrapper class）, 由它来提供相应的迭代器。 
    然而请注意，有些“像容器”的对象其实并未符合STL概念。例如，STL容器必须具备一个起点和一个终点，这就让环式容器（circular container）如 ring buffer之流很难融人STL框架。 
    7.1.2节第254页列出了所有容器的共通操作，并标记出STL容器绝对必须具备者。然而，请注意，这并不意味着符合所有条件才算是匹配、吻合STL框架。只履行其中部分条件，往往也就足够让某 些（但非全部）行为可以有效运作。甚至某些标准STL容器也违反STL容器条件。
    例如 forward_list就不提供size()，array也未实现“被default构造函数初始化的STL容器是个空容器”这样的一般条件。 

派生自 STL Type 
    
    另一个问题是，你是否可以借由“派生自STL type并为它们添加行为”来扩充它们。可惜的是往往不可能。基于效率考虑，所有STL class都不带virtual函数，也因此不在public继承中提供多态（polymorphism）。如果要为容器添加新行为，你应该定义一个新class,
    其内使用STL class 其是以private方式继承STL class。 
